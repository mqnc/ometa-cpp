

#include "ometa.h"

#include <cassert>
#include <iostream>
#include <fstream>
#include <cmath>
#include <string>
#include <ctime>

using ViewTree = ometa::ViewTree<std::string_view>;

int main(int argc, char* argv[]) {

	if(argc != 3){
		std::cout << "usage: " << argv[0] << " INPUT_FILE OUTPUT_FILE\n";
		return EXIT_FAILURE;
	}

	_ := <(" " | "\t" | "\n")*>;

	identStart := {'A'}..{'Z'} | {'a'}..{'z'} | "_" | "::";
	identContinue := identStart | {'0'}..{'9'};
	identifier := <identStart identContinue*>;
	reference := identifier ~"^" -> {'"ometa::ptr("' + $ + '")"'};

	cppChar := ~"\\" ~. | ~.;
	cppLiteral := <
		~"'" ~(!"'" ~cppChar)* ~"'"
		| ~"\"" ~(!"\"" ~cppChar)* ~"\""
	>;
	
	viewTreeLiteral :=
		~"'" <"\"" ~(!"'" !"\"" ~cppChar)* ~"\""> ~"'"
	{'"_tree_"'} -> ometa::concat;

	valueRef := ~"$" -> {'"value"'};
	indexedValueRef := ~"$" <{'0'}..{'9'}+> -> {'"ometa::pick<"' + $ + '">(value)"'};
	taggedValueRef := ~"$" identifier -> {'"ometa::pick<\""' + $ + '"\">(value)"'};

	cppExpression^ : {std::string_view} -> {ViewTree};
	parenthesizedCppExpression := ~"(" cppExpression^ ~")";
	bracketedCppExpression := ~"[" cppExpression^ ~"]";
	bracedCppExpression := ~"{" cppExpression^ ~"}";
	predicateCppExpression := ~"{" ~_ ~ "?" cppExpression^ ~"}";

	cppExpression^ => (
		identifier {? $ && *$ != "return"}
		| viewTreeLiteral
		| cppLiteral
		| parenthesizedCppExpression -> {'"("' + $ + '")"'}
		| bracketedCppExpression -> {'"["' + $ + '"]"'}
		| indexedValueRef
		| taggedValueRef
		| valueRef
		| !")" !"]" !"}" !";" .
	)* -> ometa::concat;

	cppCode^ : {std::string_view} -> {ViewTree};
	parenthesizedCppCode := ~"(" cppCode^ ~")";
	bracketedCppCode := ~"[" cppCode^ ~"]";
	bracedCppCode := ~"{" cppCode^ ~"}";
	predicateCppCode := ~"{" ~_ ~ "?" cppCode^ ~"}";

	ruleForwardDecl^ : {std::string_view} -> {ViewTree};
	ruleDefinition^ : {std::string_view} -> {ViewTree};
	ruleRedefinition^ : {std::string_view} -> {ViewTree};
	macroDefinition^ : {std::string_view} -> {ViewTree};

	cppCode^ => (
		ruleForwardDecl^
		| ruleDefinition^
		| ruleRedefinition^
		| macroDefinition^
		| identifier
		| viewTreeLiteral
		| cppLiteral
		| parenthesizedCppCode -> {'"("' + $ + '")"'}
		| bracketedCppCode -> {'"["' + $ + '"]"'}
		| bracedCppCode -> {'"{"' + $ + '"}"'}
		| indexedValueRef
		| taggedValueRef
		| valueRef
		| !")" !"]" !"}" .
	)* -> ometa::concat;

	any := "." -> {'"ometa::any()"'};
	epsilon := "()" -> {'"ometa::epsilon()"'};

	character :=
		~"\\" ~("n" | "r" | "t" | "\"" | "\\")
		| !"\\" ~.;
	literal := <"\"" (!"\"" character)* "\"">
		{'"_lit_"'} -> ometa::concat;

	range := bracedCppCode ~_ ~".." ~_ bracedCppCode -> {
		'"ometa::range(("' + $0 + '"), ("' + $1 + '"))"'
	};

	expression^ : {std::string_view} -> {ViewTree};
	parenthesized := ~"(" ~_ expression^ ~_ ~")" ->
		{'"("' + $ + '")"'};
	capture := ~"<" ~_ expression^ ~_ ~">" ->
		{'"ometa::capture("' + $ + '")"'};

	action :=
		identifier
		| bracedCppExpression -> {'"ometa::action([](auto value, const auto& context){return "' + $ + '";})"'}
		| bracedCppCode -> {'"ometa::action([](auto value, const auto& context){"' + $ + '"})"'};
	predicate :=
		identifier
		| predicateCppExpression -> {'"ometa::predicate([](auto value, const auto& context){return "' + $ + '";})"'}
		| predicateCppCode -> {'"ometa::predicate([](auto value, const auto& context){"' + $ + '"})"'};

	parameterizedAction := ~"->" {'" >= "'} ~_ action -> ometa::concat;

	macroCall := identifier ~_ ~"[" {'"("'} ~_
		expression^ ~_ ("," {'" "'} ~_ expression^ -> ometa::concat)*
		~_ ~"]" {'")"'} -> ometa::concat;

	primary :=
		reference
		| macroCall
		| any
		| epsilon
		| literal
		| range
		| capture
		| predicate
		| action
		| parenthesized;

	optional := "?" -> {'"-"'};
	zeroOrMore := "*" -> {'"*"'};
	oneOrMore := "+" -> {'"+"'};
	repetition := optional | zeroOrMore | oneOrMore;
	tag := ~":" ~_ identifier -> {'".as<\""' + $ + '"\">()"'};

	postfixed := primary ~_ tag? ~_ repetition? ~_ tag?
		-> { 
			auto result = $0;
			if ($1.size() == 1) {result = result + $1[0];}
			if ($2.size() == 1) {result = $2[0] + result;}
			if ($3.size() == 1) {result = '"("' + result + '")"' + $3[0];}
			return result;
		};

	prefixed := <("&" | "!" | "~")?>
		~_ postfixed -> ometa::concat;

	sequence := prefixed (
		(~_ (
			{'" > "'} prefixed -> ometa::concat
			| parameterizedAction
		)) -> ometa::concat
	)* -> ometa::concat;

	choice := sequence (
		<_ "|" _> sequence -> ometa::concat
	)* -> ometa::concat;

	expression^ => choice;

	ruleForwardDecl^ => identifier ~"^" ~_ ~":" ~_
		bracedCppExpression ~_ ~"->" ~_ bracedCppExpression ~_ ~";"
		-> {
			'"auto "' + $0 + '" = ometa::declare<"'
				+ $1 + '", "' + $2 + '">();"'
		};

	ruleDefinition^ => identifier ~_ ~":=" ~_ expression^ ~_ ~";"
		-> {'"const auto "' + $0 + '" = "' + $1 + '"; OMETA_LOG("' + $0 + '");"'};

	ruleRedefinition^ => identifier ~"^" ~_ ~"=>" ~_ expression^ ~_ ~";"
		-> {'"*"' + $0 + '" = "' + $1 + '"; OMETA_LOG(*"' + $0 + '");"'};

	macroParameterList := ~"[" ~_ {'"auto "'} identifier ~_
		(~"," ~_ identifier -> {'", auto "' + $})* ~_ ~"]"
		-> ometa::concat;
	macroDefinition^ => identifier ~_ macroParameterList ~_ ~":=" ~_ expression^ ~_ ~";"
		-> {
			'"const auto "' + $0 + '" = [=]("' + $1 + '"){return "' + $2 + '";};"'
		};

	auto code = ometa::readFile(argv[1]);

	auto result = cppCode->parse(code);
	if (result) {
		try {
			auto backup = ometa::readFile(argv[2]);
			std::time_t time = std::time({});
			char timeString[std::size("yyyy_mm_dd__hh_mm_ssZ")];
			std::strftime(std::data(timeString), std::size(timeString),
				"%Y_%m_%d__%H_%M_%S", std::gmtime(&time));
			ometa::writeFile(std::string(argv[2]) + "." + timeString + ".backup", backup);
		}
		catch (...) {}

		ometa::writeFile(argv[2], *result);
	}
	else {
		std::cout << "fail\n";
		return EXIT_FAILURE;
	}

	return EXIT_SUCCESS;
}
