

#include "src/ometa.h"

#include <cassert>
#include <iostream>
#include <fstream>
#include <cmath>
#include <string>

namespace o = ometa;
using o::operator""_L;
using o::concat;

using Snippet = std::string;
Snippet toSnippet(o::SourceView<std::string> src) {
	return src.copyAs<Snippet>();
}
auto operator""_S(const char* compare, size_t size) {
	return Snippet(compare, size);
}

int main(int argc, char* argv[]) {

	identStart := {'A'}..{'Z'} | {'a'}..{'z'} | "_";
	identContinue := identStart | {'0'}..{'9'};
	identifier := <identStart identContinue*> -> toSnippet;
	reference := ~"@" identifier -> {return "o::ref("_S + value + ")"_S;};

	cppChar := ~"\\" ~. | ~.;
	cppLiteral := <
		~"'" !"'" ~cppChar ~"'"
		| ~"\"" ~(!"\"" ~cppChar)* ~"\""
	> -> toSnippet;

	(cpp) := {std::string} -> {Snippet};

	(ruleForwardDecl) := {std::string} -> {Snippet};
	(ruleDefinition) := {std::string} -> {Snippet};
	(ruleRedefinition) := {std::string} -> {Snippet};

	bracedCpp := ~"{" @cpp ~"}";
	
	cpp :> (
		@ruleForwardDecl
		| @ruleDefinition
		| @ruleRedefinition
		| identifier
		| cppLiteral
		| bracedCpp -> { return "{"_S + value + "}"_S; }
		| !"}" . -> toSnippet
	)* -> concat;

	_ := (" " | "\t" | "\n")* -> {return " "_S;};

	any := "." -> {return "o::any()"_S;};
	epsilon := "()" -> {return "o::epsilon()"_S;};

	character :=
		~"\\" ~("n" | "r" | "t" | "\"" | "\\")
		| !"\\" ~.;
	literal := <"\"" (!"\"" character)* "\""> -> toSnippet
		^{return "_L"_S;} -> concat;

	range := bracedCpp ~_ ~".." ~_ bracedCpp -> {
		return "o::range(("_S
			+ o::pick<0>(value)
			+ "), ("_S
			+ o::pick<1>(value)
			+ "))"_S;
	};

	(choice) := {std::string} -> {Snippet};
	parenthesized := ~"(" ~_ @choice ~_ ~")" ->
		{ return "("_S + value + ")"_S; };
	capture := ~"<" ~_ @choice ~_ ~">" ->
		{ return "o::capture("_S + value + ")"_S; };

	action :=
		identifier -> toSnippet
		| bracedCpp -> { return "[](auto value){"_S + value + "}"_S; };
	predicate := ~"?" ~_ (
		identifier -> toSnippet
		| bracedCpp -> { return "[](auto value){"_S + value + "}"_S; }
	);

	freeActionOrPredicate := ~"^" ~_ ^{ return "(o::epsilon()"_S; }(
		^{return " >= "_S;} action
		| ^{return " <= "_S;} predicate
	) ^{return ")"_S;} -> concat;

	boundActionOrPredicate := ~"->" ~_ (
		^{return " >= "_S;} action
		| ^{return " <= "_S;} predicate
	) -> concat;

	primary :=
		identifier
		| reference
		| any
		| epsilon
		| literal
		| range
		| capture
		| freeActionOrPredicate
		| parenthesized;

	postfix := primary (
		"?" -> {return "-"_S;}
		| "*" -> {return "*"_S;}
		| "+" -> {return "+"_S;}
	)? -> {
		if (pick<1>(value).size() == 0) {
			return pick<0>(value);
		}
		else {
			return pick<1>(value)[0] + pick<0>(value);
		}
	};

	prefix := <("&" | "!" | "~")?> -> toSnippet
		~_ postfix -> concat;

	sequence := prefix (
		(~_ (
			^{return " > "_S;} prefix -> concat
			| boundActionOrPredicate
		)) -> concat
	)* -> concat;

	choice :> sequence (
		~_ "|" -> {return " | "_S;} ~_ sequence -> concat
	)* -> concat;

	ruleForwardDecl :> ~"(" ~_ identifier ~_ ~")" ~_ ~":=" ~_
		bracedCpp ~_ ~"->" ~_ bracedCpp ~_ ~";"
		-> {
			return "auto "_S + pick<0>(value) + " = o::dummy<"
				+ pick<1>(value) + ", " + pick<2>(value) + ">();";
		};

	ruleDefinition :> identifier ~_ ~":=" ~_ choice ~_ ~";"
		-> { return "auto "_S + pick<0>(value) + " = "_S + pick<1>(value) + ";"; };

	ruleRedefinition :> identifier ~_ ~":>" ~_ choice ~_ ~";"
		-> { return pick<0>(value) + " = "_S + pick<1>(value) + ";"; };


	auto code = o::readFile("../ometa.ometa");

	auto result = cpp.parse(code);
	if (result) {
		o::writeFile("../ometa-self.ometa.cpp", *result);
	}
	else {
		std::cout << "fail\n";
	}

	return EXIT_SUCCESS;
}
