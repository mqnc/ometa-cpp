

#include "src/ometa.h"

#include <cassert>
#include <iostream>
#include <fstream>
#include <cmath>
#include <string>
#include <ctime>

namespace o = ometa;
using o::operator""_L;
using o::concat;

using Snippet = std::string;
Snippet toSnippet(o::SourceView<std::string> src) {
	return src.copyAs<Snippet>();
}
auto operator""_S(const char* compare, size_t size) {
	return Snippet(compare, size);
}

int main(int argc, char* argv[]) {

	auto tStart = tic();

	_ := <(" " | "\t" | "\n")*> -> toSnippet;

	identStart := {'A'}..{'Z'} | {'a'}..{'z'} | "_";
	identContinue := identStart | {'0'}..{'9'};
	identifier := <identStart identContinue*> -> toSnippet;
	reference := identifier ~"'" -> {return "o::ptr("_S + $ + ")"_S;};

	cppChar := ~"\\" ~. | ~.;
	cppLiteral := <
		~"'" !"'" ~cppChar ~"'"
		| ~"\"" ~(!"\"" ~cppChar)* ~"\""
	> -> toSnippet;

	valueRef := ~"$" -> {return "value"_S;};
	indexedValueRef := ~"$" <{'0'}..{'9'}+> -> toSnippet -> {return "o::pick<"_S + $ + "-1>(value)"_S;};

	cpp' : {std::string} -> {Snippet};

	ruleForwardDecl' : {std::string} -> {Snippet};
	ruleDefinition' : {std::string} -> {Snippet};
	ruleRedefinition' : {std::string} -> {Snippet};

	bracedCpp := ~"{" cpp' ~"}";
	
	cpp' => (
		ruleForwardDecl'
		| ruleDefinition'
		| ruleRedefinition'
		| identifier
		| cppLiteral
		| bracedCpp -> { return "{"_S + $ + "}"_S; }
		| indexedValueRef
		| valueRef
		| !"}" . -> toSnippet
	)* -> concat;

	any := "." -> {return "o::any()"_S;};
	epsilon := "()" -> {return "o::epsilon()"_S;};

	character :=
		~"\\" ~("n" | "r" | "t" | "\"" | "\\")
		| !"\\" ~.;
	literal := <"\"" (!"\"" character)* "\""> -> toSnippet
		^{return "_L"_S;} -> concat;

	range := bracedCpp ~_ ~".." ~_ bracedCpp -> {
		return "o::range(("_S + $1 + "), ("_S + $2 + "))"_S;
	};

	choice' : {std::string} -> {Snippet};
	parenthesized := ~"(" ~_ choice' ~_ ~")" ->
		{ return "("_S + $ + ")"_S; };
	capture := ~"<" ~_ choice' ~_ ~">" ->
		{ return "o::capture("_S + $ + ")"_S; };

	action :=
		identifier -> toSnippet
		| bracedCpp -> { return "[](auto value){"_S + $ + "}"_S; };
	predicate := ~"?" ~_ (
		identifier -> toSnippet
		| bracedCpp -> { return "[](auto value){"_S + $ + "}"_S; }
	);

	freeActionOrPredicate := ~"^" ~_ ^{ return "(o::epsilon()"_S; }(
		^{return " >= "_S;} action
		| ^{return " <= "_S;} predicate
	) ^{return ")"_S;} -> concat;

	boundActionOrPredicate := ~"->" ~_ (
		^{return " >= "_S;} action
		| ^{return " <= "_S;} predicate
	) -> concat;

	primary :=
		reference
		| identifier
		| any
		| epsilon
		| literal
		| range
		| capture
		| freeActionOrPredicate
		| parenthesized;

	postfix := primary (
		"?" -> {return "-"_S;}
		| "*" -> {return "*"_S;}
		| "+" -> {return "+"_S;}
	)? -> {
		if ($2.size() == 0) {
			return $1;
		}
		else {
			return $2[0] + $1;
		}
	};

	prefix := <("&" | "!" | "~")?> -> toSnippet
		~_ postfix -> concat;

	sequence := prefix (
		(~_ (
			^{return " > "_S;} prefix -> concat
			| boundActionOrPredicate
		)) -> concat
	)* -> concat;

	choice' => sequence (
		<_ "|" _> -> toSnippet sequence -> concat
	)* -> concat;

	ruleForwardDecl' => identifier ~"'" ~_ ~":" ~_
		bracedCpp ~_ ~"->" ~_ bracedCpp ~_ ~";"
		-> {
			return "auto "_S + $1 + " = o::declare<"
				+ $2 + ", " + $3 + ">();";
		};

	ruleDefinition' => identifier ~_ ~":=" ~_ choice' ~_ ~";"
		-> { return "const auto "_S + $1 + " = "_S + $2 + ";"; };

	ruleRedefinition' => identifier ~"'" ~_ ~"=>" ~_ choice' ~_ ~";"
		-> { return "*"_S + $1 + " = "_S + $2 + ";"; };

	std::cout << "setup: ";
	toc(tStart);


	auto code = o::readFile("../ometa.ometa");

	auto result = cpp->parse(code);
	if (result) {
		try {
			auto backup = o::readFile("../ometa.ometa.cpp");
			std::time_t time = std::time({});
			char timeString[std::size("yyyy_mm_dd__hh_mm_ssZ")];
			std::strftime(std::data(timeString), std::size(timeString),
				"%Y_%m_%d__%H_%M_%S", std::gmtime(&time));
			o::writeFile(std::string("../ometa.ometa.cpp.") + timeString + ".backup", backup);
		}
		catch (...) {}

		o::writeFile("../ometa.ometa.cpp", *result);
	}
	else {
		std::cout << "fail\n";
	}

	return EXIT_SUCCESS;
}
